{
  "version": 3,
  "sources": ["../src/lib/utils.ts", "../src/services/psp-detector.ts", "../src/services/dom-observer.ts", "../src/content.ts"],
  "sourcesContent": ["/**\n * Debounce function to limit the rate at which a function can fire\n * @param func - The function to debounce\n * @param wait - The number of milliseconds to wait\n */\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number,\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout | null = null;\n\n  return (...args: Parameters<T>): void => {\n    const later = () => {\n      timeout = null;\n      func(...args);\n    };\n\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n\n    timeout = setTimeout(later, wait);\n  };\n}\n\n/**\n * Create a safe URL by sanitizing the input\n * @param url - The URL to sanitize\n */\nexport function createSafeUrl(url: string): string {\n  try {\n    return new URL(url).toString();\n  } catch (e) {\n    console.error(\"Invalid URL:\", e);\n    return \"#\";\n  }\n}\n\n/**\n * Safely compile a regex pattern\n * @param pattern - The regex pattern to compile\n */\nexport function safeCompileRegex(pattern: string): RegExp | null {\n  try {\n    return new RegExp(pattern, \"i\");\n  } catch (error) {\n    console.error(`Invalid regex pattern: ${pattern}`, error);\n    return null;\n  }\n}\n\n/**\n * Check if a URL should be excluded from PSP detection\n * @param url - The URL to check\n * @param exemptPattern - The pattern of exempt domains\n */\nexport function isUrlExempt(url: string, exemptPattern: RegExp): boolean {\n  try {\n    return !exemptPattern.test(url);\n  } catch (error) {\n    console.error(\"Error checking URL exemption:\", error);\n    return true;\n  }\n}\n\n/**\n * Create error with context for better debugging\n * @param message - Error message\n * @param context - Additional context for the error\n */\nexport function createContextError(\n  message: string,\n  context?: Record<string, unknown>,\n): Error {\n  const error = new Error(message);\n  if (context) {\n    Object.assign(error, { context });\n  }\n  return error;\n}\n\n/**\n * Logger utility with different log levels\n */\nexport const logger = {\n  debug: (message: string, ...args: any[]): void => {\n    if (process.env.NODE_ENV === \"development\") {\n      console.debug(message, ...args);\n    }\n  },\n  info: (message: string, ...args: any[]): void => {\n    console.log(message, ...args);\n  },\n  warn: (message: string, ...args: any[]): void => {\n    console.warn(message, ...args);\n  },\n  error: (message: string, ...args: any[]): void => {\n    console.error(message, ...args);\n  },\n};\n", "import type { PSP, PSPConfig } from \"../types\";\nimport { safeCompileRegex, logger } from \"../lib/utils\";\n\n/**\n * Service for detecting Payment Service Providers (PSPs) on a page.\n * @class\n */\nexport class PSPDetectorService {\n  private pspConfig: PSPConfig | null = null;\n  private exemptDomainsRegex: RegExp | null = null;\n\n  /**\n   * Initialize the PSP detector with configuration\n   * @param {PSPConfig} config - PSP configuration\n   * @return {void}\n   */\n  public initialize(config: PSPConfig): void {\n    this.pspConfig = config;\n    this.precompileRegexPatterns();\n  }\n\n  /**\n   * Set the exempt domains regex pattern\n   * @param {string} pattern - Regex pattern for exempt domains\n   * @return {void}\n   */\n  public setExemptDomainsPattern(pattern: string): void {\n    try {\n      this.exemptDomainsRegex = new RegExp(pattern);\n    } catch (error) {\n      logger.error(\"Invalid exempt domains pattern:\", error);\n      this.exemptDomainsRegex = null;\n    }\n  }\n\n  /**\n   * Detect PSP on the current page\n   * @param {string} url - The URL to check\n   * @param {string} content - The page content to scan\n   * @return {string|null} PSP name or null\n   */\n  public detectPSP(url: string, content: string): string | null {\n    if (!this.pspConfig || !this.exemptDomainsRegex) {\n      logger.warn(\"PSP detector not properly initialized\");\n      return null;\n    }\n\n    if (!this.exemptDomainsRegex.test(url)) {\n      logger.debug(\"URL is exempt from PSP detection:\", url);\n      return null;\n    }\n\n    const pageContent = `${url}\\n\\n${content}`;\n\n    for (const psp of this.pspConfig.psps) {\n      if (psp.compiledRegex && psp.compiledRegex.test(pageContent)) {\n        logger.info(\"PSP detected:\", psp.name);\n        return psp.name;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Precompile regex patterns for better performance\n   * @private\n   * @return {void}\n   */\n  private precompileRegexPatterns(): void {\n    if (!this.pspConfig) return;\n\n    for (const psp of this.pspConfig.psps) {\n      const compiled = safeCompileRegex(psp.regex);\n      psp.compiledRegex = compiled === null ? undefined : compiled;\n    }\n  }\n\n  /**\n   * Check if the detector is initialized\n   * @return {boolean} True if initialized, false otherwise\n   */\n  public isInitialized(): boolean {\n    return !!this.pspConfig && !!this.exemptDomainsRegex;\n  }\n\n  /**\n   * Get PSP by name\n   * @param {string} name - PSP name\n   * @return {PSP|null} PSP object or null\n   */\n  public getPSPByName(name: string): PSP | null {\n    if (!this.pspConfig) {\n      return null;\n    }\n\n    return this.pspConfig.psps.find((psp) => psp.name === name) || null;\n  }\n}\n", "import { debounce, logger } from \"../lib/utils\";\n\n/**\n * Service for observing DOM mutations and triggering callbacks.\n * @class\n */\nexport class DOMObserverService {\n  private observer: MutationObserver | null = null;\n  private onMutationCallback: (() => void) | null = null;\n  private isObserving = false;\n\n  /**\n   * Initialize the observer with a callback\n   * @param {() => void} callback - Function to call when mutations are observed\n   * @param {number} [debounceMs=2000] - Debounce time in milliseconds\n   * @return {void}\n   */\n  public initialize(callback: () => void, debounceMs = 2000): void {\n    this.onMutationCallback = debounce(callback, debounceMs);\n    this.observer = new MutationObserver((mutations) => {\n      if (!this.isObserving || !this.onMutationCallback) return;\n      for (const mutation of mutations) {\n        if (mutation.type === \"childList\" && mutation.addedNodes.length > 0) {\n          this.onMutationCallback();\n          break;\n        }\n      }\n    });\n  }\n\n  /**\n   * Start observing DOM mutations\n   * @return {void}\n   */\n  public startObserving(): void {\n    if (!this.observer || this.isObserving) return;\n    const start = () => {\n      if (!document.body) {\n        document.addEventListener(\"DOMContentLoaded\", start, { once: true });\n        return;\n      }\n      try {\n        this.observer!.observe(document.body, {\n          childList: true,\n          subtree: true,\n        });\n        this.isObserving = true;\n        logger.debug(\"DOM observer started\");\n      } catch (error) {\n        logger.error(\"Failed to start DOM observer:\", error);\n      }\n    };\n    start();\n  }\n\n  /**\n   * Stop observing DOM mutations\n   * @return {void}\n   */\n  public stopObserving(): void {\n    if (!this.observer || !this.isObserving) return;\n    try {\n      this.observer.disconnect();\n      this.isObserving = false;\n      logger.debug(\"DOM observer stopped\");\n    } catch (error) {\n      logger.error(\"Failed to stop DOM observer:\", error);\n    }\n  }\n\n  /**\n   * Clean up the observer\n   * @return {void}\n   */\n  public cleanup(): void {\n    this.stopObserving();\n    this.observer = null;\n    this.onMutationCallback = null;\n  }\n\n  /**\n   * Check if the observer is currently active\n   * @return {boolean} True if observing, false otherwise\n   */\n  public isActive(): boolean {\n    return this.isObserving;\n  }\n}\n", "/**\n * Content script for PSP Detector Chrome Extension.\n * Handles DOM observation, PSP detection, and communication with background script.\n * @module content\n */\nimport { PSPDetectorService } from \"./services/psp-detector\";\nimport { DOMObserverService } from \"./services/dom-observer\";\nimport { MessageAction, ChromeMessage } from \"./types\";\nimport { logger } from \"./lib/utils\";\n\nclass ContentScript {\n  private pspDetector: PSPDetectorService;\n  private domObserver: DOMObserverService;\n  private pspDetected = false;\n\n  constructor() {\n    this.pspDetector = new PSPDetectorService();\n    this.domObserver = new DOMObserverService();\n  }\n\n  /**\n   * Initialize the content script\n   * @return {Promise<void>}\n   */\n  public async initialize(): Promise<void> {\n    try {\n      await this.initializeExemptDomains();\n      await this.initializePSPConfig();\n      this.setupDOMObserver();\n      this.detectPSP();\n    } catch (error) {\n      logger.error(\"Failed to initialize content script:\", error);\n    }\n  }\n\n  /**\n   * Initialize exempt domains configuration\n   * @private\n   * @return {Promise<void>}\n   */\n  private async initializeExemptDomains(): Promise<void> {\n    try {\n      const response = await this.sendMessage<{ regex: string }>({\n        action: MessageAction.GET_EXEMPT_DOMAINS_REGEX,\n      });\n      if (response?.regex) {\n        this.pspDetector.setExemptDomainsPattern(response.regex);\n      }\n    } catch (error) {\n      logger.error(\"Failed to initialize exempt domains:\", error);\n    }\n  }\n\n  /**\n   * Initialize PSP configuration\n   * @private\n   * @return {Promise<void>}\n   */\n  private async initializePSPConfig(): Promise<void> {\n    try {\n      const response = await this.sendMessage<{ config: any }>({\n        action: MessageAction.GET_PSP_CONFIG,\n      });\n      if (response?.config) {\n        this.pspDetector.initialize(response.config);\n      }\n    } catch (error) {\n      logger.error(\"Failed to initialize PSP config:\", error);\n    }\n  }\n\n  /**\n   * Set up DOM observer\n   * @private\n   * @return {void}\n   */\n  private setupDOMObserver(): void {\n    this.domObserver.initialize(() => this.detectPSP());\n    this.domObserver.startObserving();\n  }\n\n  /**\n   * Detect PSP on the current page\n   * @private\n   * @return {Promise<void>}\n   */\n  private async detectPSP(): Promise<void> {\n    if (this.pspDetected || !this.pspDetector.isInitialized()) {\n      return;\n    }\n    const detectedPsp = this.pspDetector.detectPSP(\n      document.URL,\n      document.documentElement.outerHTML,\n    );\n    if (detectedPsp) {\n      try {\n        const tabResponse = await this.sendMessage<{ tabId: number }>({\n          action: MessageAction.GET_TAB_ID,\n        });\n        if (tabResponse?.tabId) {\n          await this.sendMessage({\n            action: MessageAction.DETECT_PSP,\n            data: { psp: detectedPsp, tabId: tabResponse.tabId },\n          });\n        }\n        this.pspDetected = true;\n        this.domObserver.stopObserving();\n      } catch (error) {\n        logger.error(\"Failed to report detected PSP:\", error);\n      }\n    }\n  }\n\n  /**\n   * Send a message to the background script\n   * @private\n   * @template T\n   * @param {ChromeMessage} message - Message to send\n   * @return {Promise<T>} Response from background\n   */\n  private sendMessage<T = any>(message: ChromeMessage): Promise<T> {\n    return new Promise((resolve, reject) => {\n      try {\n        chrome.runtime.sendMessage(message, (response) => {\n          if (chrome.runtime.lastError) {\n            reject(chrome.runtime.lastError);\n          } else {\n            resolve(response);\n          }\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n}\n\n// Initialize content script\nconst contentScript = new ContentScript();\ncontentScript.initialize().catch((error) => {\n  logger.error(\"Content script initialization failed:\", error);\n});\n"],
  "mappings": "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",
  "names": ["debounce", "func", "wait", "timeout", "args", "later", "safeCompileRegex", "pattern", "error", "logger", "message", "args", "PSPDetectorService", "config", "pattern", "error", "logger", "url", "content", "pageContent", "psp", "compiled", "safeCompileRegex", "name", "DOMObserverService", "callback", "debounceMs", "debounce", "mutations", "mutation", "start", "logger", "error", "ContentScript", "PSPDetectorService", "DOMObserverService", "error", "logger", "response", "detectedPsp", "tabResponse", "message", "resolve", "reject", "contentScript"]
}
